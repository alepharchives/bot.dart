        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Runner class / hop Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="http://fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="hop" data-type="Runner">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../hop.html">hop</a> &rsaquo; <a href="../hop/Runner.html">Runner</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>Runner</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<pre class="source">
class Runner {
 final ArgParser _parser;
 ArgResults _args;
 final HopConfig _state;

 Runner(HopConfig config, Iterable&lt;String&gt; args) :
   this._state = config,
   this._parser = _getParser(config) {
   _args = _parser.parse(args);
   _state.requireFrozen();
 }

 Runner._internal(this._state, this._parser, this._args);

 Future&lt;RunResult&gt; run() {
   assert(_state.isFrozen);

   final ctx = getContext();

   if(_args.command != null) {
     // we're executing a command
     final subCommandArgResults = _args.command;
     final taskName = subCommandArgResults.name;

     var subCtx = ctx.getSubContext(taskName, subCommandArgResults);

     final task = _state._getTask(taskName);
     return runTask(subCtx, task)
         .then((RunResult result) =&gt; _logExitCode(ctx, result))
         .whenComplete(() =&gt; subCtx.dispose());

   } else if(_args.rest.length == 0) {
     _printHelp(_state);
     return new Future.immediate(RunResult.SUCCESS);
   } else {
     final taskName = _args.rest[0];
     ctx.log('No task named "$taskName".');
     return new Future.immediate(RunResult.BAD_USAGE);
   }
 }

 @protected
 RootTaskContext getContext() {
   final bool colorEnabled = _args[_colorFlag];
   final bool preFixEnabled = _args[_prefixFlag];
   final String logLevelOption = _args[_logLevelOption];

   final Level logLevel = _getLogLevels()
       .singleMatching((Level l) =&gt; l.name.toLowerCase() == logLevelOption);

   return new RootTaskContext(colorEnabled: colorEnabled,
       prefixEnabled: preFixEnabled, minLogLevel: logLevel);
 }

 /**
  * Parses provided command line args
  * Handles command completion with the correct paramaters
  *
  * [runCore] calls [io.exit] which terminates the application.
  *
  * [runCore] should be the last method you call in an application.
  */
 static void runCore(HopConfig config) {
   final options = new Options();

   final parser = _getParser(config);

   ArgResults args;
   try {
     args = tryArgsCompletion(parser);
   } on FormatException catch(ex, stack) {
     config.doPrint("There was an error parsing the provided arguments");
     config.doPrint(ex.message);
     config.doPrint('');
     _printHelp(config);

     _libLogger.severe(ex.message);
     _libLogger.severe(Error.safeToString(stack));

     io.exit(RunResult.BAD_USAGE.exitCode);
   }

   final runner = new Runner._internal(config, parser, args);
   final future = runner.run();

   future.then((RunResult rr) {
     _libLogger.info('Exit with $rr');
     io.exit(rr.exitCode);
   });
 }

 /**
  * Runs a [Task] with the specificed [TaskContext].
  *
  * [runTask] handles a number of error cases, logs appropriate messages
  * to [context] and returns a corresponding [RunResult] when completed.
  */
 static Future&lt;RunResult&gt; runTask(TaskContext context, Task task) {
   requireArgumentNotNull(context, 'context');
   requireArgumentNotNull(task, 'task');
   requireArgument(!context.isDisposed, 'context', 'cannot be disposed');

   return task.run(context)
       .then((bool didComplete) {
         if(didComplete == null) {
           context.severe('${didComplete} returned from task');
           context.severe('Return value from task must be true or false');
           return RunResult.ERROR;
         } else if(didComplete) {
           return RunResult.SUCCESS;
         } else {
           return RunResult.FAIL;
         }
       })
       .catchError((AsyncError asyncError) {
         if(asyncError.error == Task._nullFutureResultEx) {
           context.severe('The provided task returned null instead of a future');
           return RunResult.ERROR;
         } else if(asyncError.error is _TaskFailError) {
           final _TaskFailError e = asyncError.error;
           context.severe(e.message);
           return RunResult.FAIL;
         }
         else {
           // has as exception, need to test this
           context.severe('Exception thrown by task');
           context.severe(asyncError.error.toString());
           if(asyncError.stackTrace != null) {
             context.severe(asyncError.stackTrace.toString());
           }
           return RunResult.EXCEPTION;
         }
       });
 }

 static RunResult _logExitCode(RootTaskContext ctx, RunResult result) {
   if(!result.success) {
     ctx.log('Task did not complete - ${result.name} (${result.exitCode})', AnsiColor.RED);
   }
   return result;
 }
}
</pre>
</div>
<div>
<h3>Static Methods</h3>
<div class="method"><h4 id="runCore">
<button class="show-code">Code</button>
void <strong>runCore</strong>(<a href="../hop/HopConfig.html">HopConfig</a> config) <a class="anchor-link" href="#runCore"
              title="Permalink to Runner.runCore">#</a></h4>
<div class="doc">
<p>Parses provided command line args
Handles command completion with the correct paramaters</p>
<p><a class="crossref" href="../hop/Runner.html#runCore">runCore</a> calls <code>io.exit</code> which terminates the application.</p>
<p><a class="crossref" href="../hop/Runner.html#runCore">runCore</a> should be the last method you call in an application.</p>
<pre class="source">
static void runCore(HopConfig config) {
 final options = new Options();

 final parser = _getParser(config);

 ArgResults args;
 try {
   args = tryArgsCompletion(parser);
 } on FormatException catch(ex, stack) {
   config.doPrint("There was an error parsing the provided arguments");
   config.doPrint(ex.message);
   config.doPrint('');
   _printHelp(config);

   _libLogger.severe(ex.message);
   _libLogger.severe(Error.safeToString(stack));

   io.exit(RunResult.BAD_USAGE.exitCode);
 }

 final runner = new Runner._internal(config, parser, args);
 final future = runner.run();

 future.then((RunResult rr) {
   _libLogger.info('Exit with $rr');
   io.exit(rr.exitCode);
 });
}
</pre>
</div>
</div>
<div class="method"><h4 id="runTask">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="../hop/RunResult.html">RunResult</a>&gt; <strong>runTask</strong>(<a href="../hop/TaskContext.html">TaskContext</a> context, <a href="../hop/Task.html">Task</a> task) <a class="anchor-link" href="#runTask"
              title="Permalink to Runner.runTask">#</a></h4>
<div class="doc">
<p>Runs a <a class="crossref" href="../hop/Task.html">Task</a> with the specificed <a class="crossref" href="../hop/TaskContext.html">TaskContext</a>.</p>
<p><a class="crossref" href="../hop/Runner.html#runTask">runTask</a> handles a number of error cases, logs appropriate messages
to 
<span class="param">context</span> and returns a corresponding <a class="crossref" href="../hop/RunResult.html">RunResult</a> when completed.</p>
<pre class="source">
static Future&lt;RunResult&gt; runTask(TaskContext context, Task task) {
 requireArgumentNotNull(context, 'context');
 requireArgumentNotNull(task, 'task');
 requireArgument(!context.isDisposed, 'context', 'cannot be disposed');

 return task.run(context)
     .then((bool didComplete) {
       if(didComplete == null) {
         context.severe('${didComplete} returned from task');
         context.severe('Return value from task must be true or false');
         return RunResult.ERROR;
       } else if(didComplete) {
         return RunResult.SUCCESS;
       } else {
         return RunResult.FAIL;
       }
     })
     .catchError((AsyncError asyncError) {
       if(asyncError.error == Task._nullFutureResultEx) {
         context.severe('The provided task returned null instead of a future');
         return RunResult.ERROR;
       } else if(asyncError.error is _TaskFailError) {
         final _TaskFailError e = asyncError.error;
         context.severe(e.message);
         return RunResult.FAIL;
       }
       else {
         // has as exception, need to test this
         context.severe('Exception thrown by task');
         context.severe(asyncError.error.toString());
         if(asyncError.stackTrace != null) {
           context.severe(asyncError.stackTrace.toString());
         }
         return RunResult.EXCEPTION;
       }
     });
}
</pre>
</div>
</div>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="Runner">
<button class="show-code">Code</button>
new <strong>Runner</strong>(<a href="../hop/HopConfig.html">HopConfig</a> config, <a href="http://api.dartlang.org/dart_core/Iterable.html">Iterable</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>&gt; args) <a class="anchor-link" href="#Runner"
              title="Permalink to Runner.Runner">#</a></h4>
<div class="doc">
<pre class="source">
Runner(HopConfig config, Iterable&lt;String&gt; args) :
 this._state = config,
 this._parser = _getParser(config) {
 _args = _parser.parse(args);
 _state.requireFrozen();
}
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="getContext">
<button class="show-code">Code</button>
<a href="../hop/RootTaskContext.html">RootTaskContext</a> <strong>getContext</strong>() <a class="anchor-link" href="#getContext"
              title="Permalink to Runner.getContext">#</a></h4>
<div class="doc">
<pre class="source">
@protected
RootTaskContext getContext() {
 final bool colorEnabled = _args[_colorFlag];
 final bool preFixEnabled = _args[_prefixFlag];
 final String logLevelOption = _args[_logLevelOption];

 final Level logLevel = _getLogLevels()
     .singleMatching((Level l) =&gt; l.name.toLowerCase() == logLevelOption);

 return new RootTaskContext(colorEnabled: colorEnabled,
     prefixEnabled: preFixEnabled, minLogLevel: logLevel);
}
</pre>
</div>
</div>
<div class="method"><h4 id="run">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="../hop/RunResult.html">RunResult</a>&gt; <strong>run</strong>() <a class="anchor-link" href="#run"
              title="Permalink to Runner.run">#</a></h4>
<div class="doc">
<pre class="source">
Future&lt;RunResult&gt; run() {
 assert(_state.isFrozen);

 final ctx = getContext();

 if(_args.command != null) {
   // we're executing a command
   final subCommandArgResults = _args.command;
   final taskName = subCommandArgResults.name;

   var subCtx = ctx.getSubContext(taskName, subCommandArgResults);

   final task = _state._getTask(taskName);
   return runTask(subCtx, task)
       .then((RunResult result) =&gt; _logExitCode(ctx, result))
       .whenComplete(() =&gt; subCtx.dispose());

 } else if(_args.rest.length == 0) {
   _printHelp(_state);
   return new Future.immediate(RunResult.SUCCESS);
 } else {
   final taskName = _args.rest[0];
   ctx.log('No task named "$taskName".');
   return new Future.immediate(RunResult.BAD_USAGE);
 }
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
